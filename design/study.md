

多态

>在电影的拍摄现场，当导演喊出“action”时，主角开始背台词，照明师负责打灯 光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时， 每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来 编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前， 确认它们的职业分工(类型)，然后告诉他们要做什么。如果映射到程序中，那么程序 中将充斥着条件分支语句



我觉得很像题库里面，当要切换下一题时，需要控制很多东西，比如头部要改变，按钮改变等等。如果它们自己有当切换题目时执行的方法，就不需要去判断各个部分该干什么。但是这里🈶个问题就是，如果采用多态，如何保证各个部分的依赖关系。比如，有的部分需要根据其他部分的状态来执行对应的操作。

>对象 应该做什么并不是临时决定的，而是已经事先约定和排练完毕的。每个对象应该做什么，已经成 为了该对象的一个方法，被安装在对象的内部，每个对象负责它们自己的行为。所以这些对象可 以根据同一个消息，有条不紊地分别进行各自的工作。

如果这样看的话，每个部分要执行的动作是事先约定好的话，各自独立，那么就不存在依赖关系。

封装
- 封装数据
- 封装实现  封装具体的实现过程
- 封装类型  静态类型语言通过抽象类和接口来进行，动态类型没有能力，也不需要。
- 封装变化  

《设计模式》将23中设计模式分别被划分为创建型模式、结构型模式、行为型模式。
**创建型封装创建对象的变化，结构型封装对象之间的组合关系，行为型封装对象行为的变化。**

### 原型模式

>假设我们在编写一个飞机大战的网页游戏。某种飞机拥有分身技能，当它使用分身技能的时 候，要在页面中创建一些跟它一模一样的飞机。如果不使用原型模式，那么在创建分身之前，无 疑必须先保存该飞机的当前血量、炮弹等级、防御等级等信息，随后将这些信息设置到新创建的 飞机上面，这样才能得到一架一模一样的新飞机。如果使用原型模式，我们只需要调用负责克隆的方法，便能完成同样的功能。

js中调用 Object.create()即可克隆对象。

```js
function Person(name){
  this.name=name
}
Person.prototype.say = function(){
  console.log(this.name);
}
var me = new Person('ltinyho')
var myClone = Object.create(me)
myClone.say();
var myClone2 = {}
myClone2.__proto__ = me;
myClone2.say();
```

原型模式一定有一个根对象，其他的对象一定是从某个已经存在的对象生成的，然后在添加它自己的属性和方法。在这些对象上就会形成一条原型链，当调用某个对象的方法时，如果在它本身没有这个方法，那么就会从原型链一直向上找，直到根对象为止。
js中的根对象为`Object.prototype`,它是这个空对象。
```js
var a = {}
Object.getPrototypeOf(a)===Object.prototype // true
```

构造函数
- 创建一个对象
- 将构造函数的作用域赋给新对象。（因此this指向了新对象）
- 执行构造函数中的代码。（为这个新对象添加属性）
- 如果不调用return ，默认返回这个对象,显式的return一个对象会影响结果，返回原始值不会。


对象的原型链是如何查找的呢?
要完成查找，每个对象首先至少得记住自己的原型，知道自己从哪里来的。`js` 给对象提供了一个名为`__proto__`的隐藏属性，某个对象的 `__proto__`属性默认指向它的构造器原型对象，即 `{Constructor}.prototype` ，当在自己找不到属性时，就会到这个对象上查找。但是一个对象的 `Constructor` 可能会被修改,但是 `Constructor` 的修改。原因是 `js`中每个对象都是从 `Object.prototype` 对象克隆而来的，如果这样的话，只能得到单一的继承关系，即每个对象都是继承于 `Object.protoype`。但是对象构造器的原型并不仅限于 `Object.prototype` 上，而是可以动态的指向其他对象。看一下以下代码：
```js
function A(){
}
A.prototype.name= 'A'
A.prototype.say = function(){
  console.log(this.name);
}
function B(){
}
var a = new A()
B.prototype = a;
var b= new B()
console.log(b.name);
b.__proto__===B.prototype // true
```
- 首先遍历 b 上的所有属性，没有找到 name 。
- 查找 name 属性的请求被委托给 b 的 `b.__proto__`， `b.__proto__`记录了构造器原型 `B.prototype`,而`B.prototype`指向一个通过 `new A()` 创建的对象。
- 然后就到 a 的 属性上遍历，还是没有。然后到`a.__proto__`记录的 `A.prototype` 上找的构造器原型上找，找到了。


注意：当在本身查找不到时，是先到 `__proto__` 上去找， 如果一个对象已经创建，`__proto__` 确定了，这时改变 这个对象的 `constructor` 并不会改变原型链。